#pragma kernel CSAggregate
#pragma kernel CSAggregate PLATFORM_LINUX
#pragma kernel CSClear
#pragma kernel CSRender

#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelData.cginc"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelLightingData.hlsl"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Radiances/Voxel.cginc"

#define RADIANCE_PRECISION 256.0

RWTexture3D<uint> RadianceColorBA;
RWTexture3D<uint> RadianceColorRG;
RWTexture3D<uint> RadianceCount;
RWTexture3D<float4> Target;
ConsumeStructuredBuffer<VoxelData> VoxelBuffer;

[numthreads(4,4,4)]
void CSAggregate(uint3 id : SV_DispatchThreadID)
{
  if (any(id >= Resolution)) return;

  // FIXME
  // It looks stupid, due to a bug in HLSL to GLSL translator (case 1241093).
  // This is an only workaround I can think of.
  uint rg = RadianceColorRG[id];
  uint ba = RadianceColorBA.Load(id);
  uint count = RadianceCount[id];

  if (count > 0) {
    float4 color = uint4(
      rg & 0xffff,
      rg >> 16,
      ba & 0xffff,
      ba >> 16
    ) / RADIANCE_PRECISION;

    Target[id] = color / count;
#ifdef PLATFORM_LINUX
  } else Target[id] = 0.0;
#else
  } else if (any(Target[id])) Target[id] = 0.0; // Write only when necessary
#endif
}

[numthreads(4,4,4)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
  if (any(id >= Resolution)) return;

  RadianceColorRG[id] = 0;
  RadianceColorBA[id] = 0;
  RadianceCount[id] = 0;
}

[numthreads(64,1,1)]
void CSRender(uint id : SV_DispatchThreadID)
{
  VoxelData data = VoxelBuffer.Consume();

  DeviceMemoryBarrierWithGroupSync();

  if (!data.IsValid()) return;

  float3 position = data.GetPosition();
  float3 normal = data.GetNormal();
  float4 color = data.GetColor();
  float3 emission = data.GetEmission();

  VoxelLightingData lightingData;
  lightingData.color = color.rgb;
  lightingData.voxelPosition = position;
  lightingData.vecN = normal;
  lightingData.Initialize();

  color.rgb = emission + VoxelRadiance(lightingData);
  color.a = saturate(color.a);

  uint4 intColor = (uint4)round(color * RADIANCE_PRECISION);

  InterlockedAdd(RadianceColorRG[position], intColor.r | intColor.g << 16);
  InterlockedAdd(RadianceColorBA[position], intColor.b | intColor.a << 16);
  InterlockedAdd(RadianceCount[position], 1);
}
